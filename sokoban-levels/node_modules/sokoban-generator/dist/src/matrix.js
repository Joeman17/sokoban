"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _tiles = require("./tiles");

var _direction = require("./direction");

var _util = require("./util");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Matrix = function () {
  function Matrix(width, height, initValue) {
    _classCallCheck(this, Matrix);

    this._width = width;
    this._height = height;
    this._data = this._emptyMatrix(width, height, initValue);
  }

  _createClass(Matrix, [{
    key: "get",
    value: function get(x, y) {
      return this._data[y][x];
    }
  }, {
    key: "set",
    value: function set(x, y, tile) {
      this._data[y][x] = tile;
    }
  }, {
    key: "setAsArray",
    value: function setAsArray(arr) {
      this._data = arr.map(function (a) {
        return a.slice();
      });
    }

    /**
     * Moves a tile to a certain direction. The movable tile is either player or
     * box. This function does not cause ripple effect (i.e. moving a player to a
     * box does not push it further, and it's also a invalid move)
     * @param x
     * @param y
     * @param direction
     * @return boolean if the move is legit and successful
     */

  }, {
    key: "move",
    value: function move(x, y, direction) {
      if (!this.isMovable(x, y)) {
        return false;
      }

      var coord = (0, _direction.moveToDirection)(x, y, direction);
      var x2 = coord.x;
      var y2 = coord.y;

      if (!this.isInRange(x2, y2) || !this.isWalkable(x2, y2)) {
        return false;
      }

      var src = this.get(x, y);
      var dest = this.get(x2, y2);
      var tile = (0, _tiles.extractMovableTile)(src);

      this.set(x, y, (0, _tiles.removeMovableTile)(src));
      this.set(x2, y2, (0, _tiles.addMovableTile)(dest, tile));

      return true;
    }
  }, {
    key: "clone",
    value: function clone() {
      var newMatrix = new Matrix(this._width, this._height);
      newMatrix._data = this._data.map(function (a) {
        return a.slice();
      });

      return newMatrix;
    }

    /**
     * Returns if current grid can be is all connected
     */

  }, {
    key: "isAllConnected",
    value: function isAllConnected() {
      // Find first floor
      var x = 0;
      var y = 0;
      for (; y < this._height; ++y) {
        x = this._data[y].indexOf(_tiles.FLOOR);

        if (x !== -1) {
          break;
        }
      }

      if (x === -1) {
        return false;
      }

      var c = this.clone();
      c._propagateFloorWith(x, y);

      return !c._data.some(function (row) {
        return row.includes(_tiles.FLOOR);
      });
    }

    /**
     * Returns whether the grid has empty area larger than 4x3 or 3x4
     */

  }, {
    key: "hasLargeEmptySpace",
    value: function hasLargeEmptySpace() {
      var map = {};
      var qualify3x3 = {};

      // Find all indices with three space
      var index = 0;
      for (var x = 0; x < this._height; ++x, index += 2) {
        var last = false;
        var last2 = false;

        for (var y = 0; y < this._width - 2; ++y, ++index) {
          var curr = this._data[y][x] === _tiles.FLOOR;

          if (curr && last && last2) {
            // Check up 3x3
            if (map[index - this._width] && map[index - this._width - this._width]) {
              // Check 4x3 or 3x4
              if (qualify3x3[index - this._width] || qualify3x3[index - 1]) {
                return true;
              }
              qualify3x3[index] = true;
            }

            map[index] = true;
          }

          last2 = last;
          last = curr;
        }
      }

      return false;
    }
  }, {
    key: "count",
    value: function count(t) {
      var i = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var row = _step.value;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = row[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var tile = _step2.value;

              if (tile === t) {
                ++i;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return i;
    }
  }, {
    key: "hasDeadEnd",
    value: function hasDeadEnd() {
      for (var x = 0; x < this._width; ++x) {
        for (var y = 0; y < this._height; ++y) {
          if (this.isWall(x, y)) {
            continue;
          }

          // this._data[i] !== WALL
          var notWall = !this.isWall(x, y - 1) ? 1 : 0;

          notWall += !this.isWall(x - 1, y) ? 1 : 0;
          if (notWall > 1) {
            continue;
          }

          notWall += !this.isWall(x + 1, y) ? 1 : 0;
          if (notWall > 1) {
            continue;
          } else if (notWall === 0) {
            return true;
          }

          notWall += !this.isWall(x, y + 1) ? 1 : 0;
          if (notWall <= 1) {
            return true;
          }
        }
      }

      return false;
    }

    /**
     * Puts boxes back to their goals and returns the final positions of the
     * boxes (or goals)
     */

  }, {
    key: "resetBoxesToGoals",
    value: function resetBoxesToGoals() {
      var goals = [];

      for (var y = 0; y < this._height; ++y) {
        for (var x = 0; x < this._width; ++x) {
          var tile = this.get(x, y);
          if (tile === _tiles.BOX) {
            this.set(x, y, _tiles.FLOOR);
          } else if (tile === _tiles.GOAL) {
            goals.push({ x: x, y: y });
            this.set(x, y, _tiles.BOX_GOAL);
          } else if (tile === _tiles.BOX_GOAL) {
            goals.push({ x: x, y: y });
          }
        }
      }

      return goals;
    }

    /**
     * Finds all available player starting positions
     * @return {[{x: number, y: number}]} A list of player positions. Each
     *   position is mutually non-accessible by other positions in the list.
     */

  }, {
    key: "findAvailablePlayerPositions",
    value: function findAvailablePlayerPositions() {
      var c = this.clone();
      var pos = [];

      for (var x = 0; x < this._width; ++x) {
        for (var y = 0; y < this._height; ++y) {
          if (c.get(x, y) === _tiles.FLOOR) {
            pos.push({ x: x, y: y });
            c._propagateFloorWith(x, y, _tiles.WALL);
          }
        }
      }

      return pos;
    }
  }, {
    key: "is",
    value: function is(x, y, tile) {
      var isEdgeConsideredTile = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      if (!this.isInRange(x, y)) {
        return isEdgeConsideredTile;
      }

      return this.get(x, y) === tile;
    }

    /**
     * Returns if a given tile is a wall
     * @param x
     * @param y
     * @return {boolean}
     */

  }, {
    key: "isWall",
    value: function isWall(x, y) {
      return this.is(x, y, _tiles.WALL, true);
    }
  }, {
    key: "isInRange",
    value: function isInRange(x, y) {
      return x >= 0 && x < this._width && y >= 0 && y < this._height;
    }

    /**
     * Returns if (x1, y1) is accessible from (x2, y2)
     * @param x1
     * @param y1
     * @param x2
     * @param y2
     * @param {array} [array] - if provided, this function will process this map
     *   instead of this._data. Should be of the same dimension as that of
     *   this._data
     * @return boolean
     */

  }, {
    key: "isAccessible",
    value: function isAccessible(x1, y1, x2, y2) {
      if (!this.isInRange(x1, y1) || !this.isInRange(x2, y2) || !this.isWalkable(x1, y1) || !this.isWalkable(x2, y2)) {
        return false;
      }

      var w = this._width;
      var h = this._height;
      var is = this.isWalkable.bind(this);

      // For this helper, we make sure (x,y) and (destX,destY) is always in
      // range, and we only change the value of x and y
      return function helper(x, y, visited) {
        if (visited[y][x]) {
          return false;
        }
        visited[y][x] = true;

        if (x === x2 && y === y2) {
          return true;
        }

        if (x > 0 && is(x - 1, y) && helper(x - 1, y, visited)) {
          return true;
        }
        if (x < w - 1 && is(x + 1, y) && helper(x + 1, y, visited)) {
          return true;
        }
        if (y > 0 && is(x, y - 1) && helper(x, y - 1, visited)) {
          return true;
        }
        if (y < h - 1 && is(x, y + 1) && helper(x, y + 1, visited)) {
          return true;
        }

        return false;
      }(x1, y1, this._emptyMatrix());
    }

    /**
     * ASSUMING (x,y) IS VALID. Returns if (x,y) is walkable.
     * @param x
     * @param y
     * @param {Array} [array] - optional array to process instead of this._data
     */

  }, {
    key: "isWalkable",
    value: function isWalkable(x, y, array) {
      return (0, _tiles.isWalkableTile)(this.get(x, y, array));
    }

    /**
     * Returns if the tile at (x,y) is movable
     * @param x
     * @param y
     * @param [array] - if specified, will be processed instead of this._data
     */

  }, {
    key: "isMovable",
    value: function isMovable(x, y, array) {
      if (!this.isInRange(x, y)) {
        return false;
      }

      var tile = this.get(x, y, array);
      return (0, _tiles.isMovableTile)(tile);
    }

    /**
     * Removes any goals tiles. This method assumes that only goal tile is GOAL
     * (thus excluding player or boxes already on goal)
     */

  }, {
    key: "clearGoals",
    value: function clearGoals() {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this._data[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var row = _step3.value;

          for (var i = 0; i < this._width; ++i) {
            if (row[i] === _tiles.GOAL) {
              row[i] = _tiles.FLOOR;
            }
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }

    /**
     * Uses DFS to spread wall at a given location
     * @param x
     * @param y
     * @param tile
     * @private
     */

  }, {
    key: "_propagateFloorWith",
    value: function _propagateFloorWith(x, y) {
      var tile = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _tiles.WALL;

      if (!this.is(x, y, _tiles.FLOOR)) {
        return;
      }

      this.set(x, y, tile);

      this._propagateFloorWith(x - 1, y, tile);
      this._propagateFloorWith(x + 1, y, tile);
      this._propagateFloorWith(x, y - 1, tile);
      this._propagateFloorWith(x, y + 1, tile);
    }
  }, {
    key: "_emptyMatrix",
    value: function _emptyMatrix() {
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._width;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._height;
      var initValue = arguments[2];

      return (0, _util.emptyMatrix)(width, height, initValue);
    }
  }, {
    key: "toString",
    value: function toString() {
      return this._data.map(function (a) {
        return a.join("");
      }).join("");
    }
  }, {
    key: "toReadableString",
    value: function toReadableString() {
      return this._data.map(function (a) {
        return a.join("");
      }).join("\n");
    }
  }]);

  return Matrix;
}();

exports.default = Matrix;
//# sourceMappingURL=matrix.js.map