{"version":3,"sources":["../../src/grid.js"],"names":["Grid","width","height","box","seed","minWall","playerPos","_width","_height","_box","_data","_rand","_seed","_minWall","_playerFixedPos","_solutionStep","x","y","get","tile","set","array","setAsArray","direction","move","isInRange","newGrid","clone","wallCount","_applyTemplate","isWall","temp","Math","floor","length","i","t","dx","dy","str","isAllConnected","hasLargeEmptySpace","hasEnoughRoom","hasDeadEnd","count","clearGoals","floors","push","j","boxes","resetBoxesToGoals","map","findAvailablePlayerPositions","pos","_pullBoxes","keys","Object","maxMap","maxPos","max","key","matrix","applyStringGrid","isAccessible","initValue","index","initBoxes","initPos","size","stack","b","step","top","shift","_pullBoxesCheckIfMapCached","newBoxPos","newPlayerPos","matrixCopy","boxesCopy","a","obj","toString","_pullBoxesPropagateMapStepValue","_emptyMatrix","playerMatrix","setValue","isWalkable","data","slice","toReadableString"],"mappings":"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","file":"grid.js","sourcesContent":["import {FLOOR, GOAL, PLAYER, PLAYER_GOAL, WALL} from \"./tiles\";\r\nimport seedrandom from \"seedrandom\";\r\nimport {DIRECTIONS, moveToDirection, oppositeDirection} from \"./direction\";\r\nimport Matrix from \"./matrix\";\r\nimport {emptyMatrix} from \"./util\";\r\nimport {TEMPLATE_SIZE, Templates} from \"./template\";\r\n\r\nexport default class Grid {\r\n  constructor(width = 0,\r\n              height = 0,\r\n              box = 3,\r\n              seed = 0,\r\n              minWall = 0,\r\n              playerPos) {\r\n    this._width = width;\r\n    this._height = height;\r\n    this._box = box;\r\n    this._data = new Matrix(this._width, this._height, FLOOR);\r\n    this._rand = seedrandom(seed);\r\n    this._seed = seed;\r\n    this._minWall = minWall;\r\n    this._playerFixedPos = playerPos;\r\n    this._solutionStep = -1;\r\n  }\r\n\r\n  get(x, y) {\r\n    return this._data.get(x, y);\r\n  }\r\n\r\n  set(x, y, tile) {\r\n    this._data.set(x, y, tile)\r\n  }\r\n\r\n  setMatrixAsArray(array) {\r\n    this._data.setAsArray(array);\r\n  }\r\n\r\n  /**\r\n   * Wrapper to move a tile\r\n   * @param x\r\n   * @param y\r\n   * @param direction\r\n   * @return boolean if the move is legit and successful\r\n   */\r\n  move(x, y, direction) {\r\n    return this._data.move(x, y, direction);\r\n  }\r\n\r\n  isInRange(x, y) {\r\n    return this._data.isInRange(x, y);\r\n  }\r\n\r\n  clone() {\r\n    let newGrid = new Grid(this._width,\r\n      this._height,\r\n      this._box,\r\n      this._seed,\r\n      this._minWall,\r\n      this._playerFixedPos);\r\n    newGrid._data = this._data.clone();\r\n    newGrid._solutionStep = this._solutionStep;\r\n\r\n    return newGrid;\r\n  }\r\n\r\n  /**\r\n   * If the grid has a solvable level, this will return the step needed to\r\n   * solve it. Only call this after a puzzle has been successfully generated\r\n   * @return {number|*}\r\n   */\r\n  getSolutionStep() {\r\n    return this._solutionStep;\r\n  }\r\n\r\n  /**\r\n   * Resets the grid and apply template.\r\n   * @return boolean - true if one is generated successfully\r\n   */\r\n  applyTemplates() {\r\n    let wallCount = 0;\r\n\r\n    for (let x = 0; x < this._width; x += TEMPLATE_SIZE) {\r\n      for (let y = 0; y < this._height; y += TEMPLATE_SIZE) {\r\n        wallCount += this._applyTemplate(x, y);\r\n      }\r\n    }\r\n\r\n    if (this._playerFixedPos) {\r\n      if (this._data.isWall(this._playerFixedPos.x, this._playerFixedPos.y)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return wallCount >= this._minWall;\r\n  }\r\n\r\n  /**\r\n   * Applies a single template at (x,y)\r\n   * @param x\r\n   * @param y\r\n   * @return {Number} the number of walls, or -1 if not created successfully\r\n   * @private\r\n   *\r\n   */\r\n  _applyTemplate(x, y) {\r\n    // Choose a random template\r\n    let temp = Templates[Math.floor(this._rand() * Templates.length)];\r\n    let i = 0;\r\n    let t = 0;\r\n\r\n    for (let dx = 0; dx < TEMPLATE_SIZE && x + dx < this._width; ++dx) {\r\n      for (let dy = 0; dy < TEMPLATE_SIZE && y + dy < this._height; ++dy, ++i) {\r\n        if (temp[i] === WALL) {\r\n          ++t;\r\n        }\r\n\r\n        this.set(x + dx, y + dy, temp[i]);\r\n      }\r\n    }\r\n\r\n    return t;\r\n  }\r\n\r\n  /**\r\n   * Applies a string grid to this class\r\n   * @param {String} str\r\n   */\r\n  applyStringGrid(str) {\r\n    let i = 0;\r\n\r\n    for (let y = 0; y < this._height; ++y) {\r\n      for (let x = 0; x < this._width; ++x) {\r\n        this.set(x, y, str[i++]);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks several things to make sure current grid is a good one for sokoban\r\n   */\r\n  isGoodCandidate() {\r\n    return this._data.isAllConnected()\r\n      && !this._data.hasLargeEmptySpace()\r\n      && this.hasEnoughRoom()\r\n      && !this._data.hasDeadEnd();\r\n  }\r\n\r\n\r\n  hasEnoughRoom() {\r\n    return this._data.count(FLOOR) >= this._box + 2; // one for player, the\r\n                                                     // other for moving\r\n  }\r\n\r\n  /**\r\n   * Wipes out any goals placed (if any) and randomly deploy goals on the\r\n   * floor\r\n   */\r\n  redeployGoals() {\r\n    this._data.clearGoals();\r\n\r\n    // Find all floors\r\n    let floors = [];\r\n    for (let x = 0; x < this._width; ++x) {\r\n      for (let y = 0; y < this._height; ++y) {\r\n        if (this.get(x, y) === FLOOR) {\r\n          floors.push({x, y});\r\n        }\r\n      }\r\n    }\r\n\r\n    if (floors.length <= this._box) {\r\n      return false;\r\n    }\r\n\r\n    // Randomly choose by shuffling\r\n    let i = floors.length;\r\n    while (--i) {\r\n      let j = Math.floor(this._rand() * (i + 1));\r\n\r\n      [floors[i], floors[j]] = [floors[j], floors[i]];\r\n    }\r\n\r\n    // Set the first several to be goals\r\n    for (let i = 0; i < this._box; ++i) {\r\n      let {x, y} = floors[i];\r\n      this.set(x, y, GOAL);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Wipes out boxes, put them back to their goals and find the farthest\r\n   * position each box can be\r\n   */\r\n  generateFarthestBoxes() {\r\n    let boxes = this._data.resetBoxesToGoals();\r\n\r\n    // Backtrack maps\r\n    let map = {};\r\n    let playerPos = this._data.findAvailablePlayerPositions();\r\n\r\n    // Generate all possible maps\r\n    for (let pos of playerPos) {\r\n      this._pullBoxes(boxes, pos, map);\r\n    }\r\n\r\n    // Iterate over map to find the farthest one\r\n    let keys = Object.keys(map);\r\n    let maxMap = \"\";\r\n    let maxPos = null;\r\n    let max = -1;\r\n\r\n    for (let key of keys) {\r\n      let matrix = map[key];\r\n\r\n      for (let x = 0; x < this._width; ++x) {\r\n        for (let y = 0; y < this._height; ++y) {\r\n          if (!matrix[y][x] || matrix[y][x] <= max) {\r\n            continue;\r\n          }\r\n\r\n          if (this._playerFixedPos) {\r\n            // The player position is fixed, so we need to know if current\r\n            // position is accessible by the player (to move the player\r\n            // position later)\r\n            this.applyStringGrid(key);\r\n            if (!this._data.isAccessible(this._playerFixedPos.x,\r\n                this._playerFixedPos.y,\r\n                x,\r\n                y)) {\r\n              continue;\r\n            }\r\n          }\r\n\r\n          maxMap = key;\r\n          maxPos = {x, y};\r\n          max = matrix[y][x];\r\n        }\r\n      }\r\n    }\r\n\r\n    if (maxPos === null) {\r\n      return false;\r\n    }\r\n\r\n    this._solutionStep = max;\r\n    this.applyStringGrid(maxMap);\r\n\r\n    // Set player position\r\n    let x = this._playerFixedPos ? this._playerFixedPos.x : maxPos.x;\r\n    let y = this._playerFixedPos ? this._playerFixedPos.y : maxPos.y;\r\n    let tile = this.get(x, y) === GOAL ? PLAYER_GOAL : PLAYER;\r\n\r\n    this.set(x, y, tile);\r\n\r\n    return true;\r\n  }\r\n\r\n//region private functions\r\n\r\n  /**\r\n   * Generates an empty matrix based on current width and height\r\n   * @return {any[][]}\r\n   * @private\r\n   */\r\n  _emptyMatrix(initValue) {\r\n    return emptyMatrix(this._width, this._height, initValue);\r\n  }\r\n\r\n  /**\r\n   * Returns actual x and y coordinate given an index in the string\r\n   * @param index\r\n   * @return {{x: number, y: number}}\r\n   * @private\r\n   */\r\n  _toCoord(index) {\r\n    let x = Math.floor(index / this._width);\r\n\r\n    return {\r\n      x,\r\n      y: index - x * this._width,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * To index\r\n   * @param x\r\n   * @param y\r\n   * @return {Number}\r\n   * @private\r\n   */\r\n  _toIndex(x, y) {\r\n    return x * this._width + y;\r\n  }\r\n\r\n  /**\r\n   * Pull all boxes to a random position (using bfs)\r\n   * @param {Array} initBoxes - an array of positions in the form of {x:number,\r\n   *   y:number}\r\n   * @param {{x:number, y:number}} initPos - current position of player\r\n   * @param {Object} map - a backtrack map to keep track of what kind of grids\r\n   *   have been explored, with each key as a string, and value as a 2d array\r\n   *   to keep track of the steps when the player is at that specific location\r\n   * @private\r\n   */\r\n  _pullBoxes(initBoxes, initPos, map) {\r\n    let size = 0;\r\n    let stack = [{\r\n      boxes : initBoxes.map(b => ({...b})),\r\n      pos   : {...initPos},\r\n      matrix: this._data.clone(),\r\n      step  : 0,\r\n    }];\r\n\r\n    while (stack.length) {\r\n      size = Math.max(stack.length, size);\r\n      let top = stack.shift();\r\n      let {boxes, pos, matrix, step} = top;\r\n\r\n      if (this._pullBoxesCheckIfMapCached(map, top)) {\r\n        continue;\r\n      }\r\n\r\n      for (let i = 0; i < boxes.length; ++i) {\r\n        let box = boxes[i];\r\n\r\n        // Go each direction\r\n        for (let direction of DIRECTIONS) {\r\n          let {x, y} = box;\r\n          let newBoxPos = moveToDirection(x, y, direction);\r\n\r\n          if (!matrix.isAccessible(pos.x,\r\n              pos.y,\r\n              newBoxPos.x,\r\n              newBoxPos.y)) {\r\n            continue;\r\n          }\r\n\r\n          let newPlayerPos = moveToDirection(newBoxPos.x,\r\n            newBoxPos.y,\r\n            direction);\r\n\r\n          if (!matrix.isAccessible(pos.x,\r\n              pos.y,\r\n              newPlayerPos.x,\r\n              newPlayerPos.y)) {\r\n            continue;\r\n          }\r\n\r\n          let matrixCopy = matrix.clone();\r\n          if (!matrixCopy.move(x, y, direction)) {\r\n            continue;\r\n          }\r\n\r\n          // Set new box position\r\n          let boxesCopy = boxes.map(a => ({...a}));\r\n          boxesCopy[i] = newBoxPos;\r\n          stack.push({\r\n            boxes : boxesCopy,\r\n            pos   : newPlayerPos,\r\n            matrix: matrixCopy,\r\n            step  : step + 1,\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * A helper function for _pullBoxes to check if the map has cached value,\r\n   * and modify the map accordingly\r\n   * @param map\r\n   * @param {{step:number, pos:object, matrix:Matrix}} obj - an object stored in\r\n   *   the stack of _pullBoxes when doing bfs\r\n   * @private\r\n   */\r\n  _pullBoxesCheckIfMapCached(map, obj) {\r\n    let {step, pos, matrix} = obj;\r\n    let {x, y} = pos;\r\n\r\n    if (step === 0) {\r\n      return false;\r\n    }\r\n\r\n    let str = matrix.toString();\r\n\r\n    // Check if the value is already cached\r\n    if (map[str]) {\r\n      if (map[str][y][x]) {\r\n        if (step < map[str][y][x]) {\r\n          this._pullBoxesPropagateMapStepValue(matrix, map[str], x, y, step);\r\n        }\r\n\r\n        return true;\r\n      }\r\n    }\r\n\r\n    if (!map[str]) {\r\n      map[str] = this._emptyMatrix(0);\r\n    }\r\n\r\n    this._pullBoxesPropagateMapStepValue(matrix,\r\n      map[str],\r\n      x,\r\n      y,\r\n      step,\r\n      true);\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Use dfs to make sure connected cells has synced step value\r\n   * @param {Matrix} matrix\r\n   * @param {Array[][]} playerMatrix - a 2d matrix that caches the max step of\r\n   *   player\r\n   * @param x\r\n   * @param y\r\n   * @param step\r\n   * @param {boolean} setValue - true if the propagation should set the value\r\n   *   and reference the actual map. Otherwise it will just propagate depending\r\n   *   on if the neighbor has a value\r\n   * @private\r\n   */\r\n  _pullBoxesPropagateMapStepValue(matrix,\r\n                                  playerMatrix,\r\n                                  x,\r\n                                  y,\r\n                                  step,\r\n                                  setValue = false) {\r\n    // if (setValue ?\r\n    //     (matrix[y][x] === step || !this._isWalkable(x, y)) : !matrix[y][x]) {\r\n    if (playerMatrix[y][x] === step || !matrix.isWalkable(x, y)) {\r\n      return;\r\n    }\r\n\r\n    playerMatrix[y][x] = step;\r\n\r\n    if (x > 0) {\r\n      this._pullBoxesPropagateMapStepValue(matrix, playerMatrix, x - 1,\r\n        y,\r\n        step,\r\n        setValue);\r\n    }\r\n\r\n    if (x < this._width - 1) {\r\n      this._pullBoxesPropagateMapStepValue(matrix, playerMatrix, x + 1,\r\n        y,\r\n        step,\r\n        setValue);\r\n    }\r\n\r\n    if (y > 0) {\r\n      this._pullBoxesPropagateMapStepValue(matrix, playerMatrix,\r\n        x, y - 1,\r\n        step,\r\n        setValue);\r\n    }\r\n\r\n    if (y < this._height - 1) {\r\n      this._pullBoxesPropagateMapStepValue(matrix, playerMatrix,\r\n        x, y + 1,\r\n        step,\r\n        setValue);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a copy of a 2d array current _data\r\n   * @private\r\n   */\r\n  _copy2dArray(data = this._data) {\r\n    return data.map(a => a.slice());\r\n  }\r\n\r\n//endregion\r\n\r\n  toString() {\r\n    return this._data.toString();\r\n  }\r\n\r\n  toReadableString() {\r\n    return this._data.toReadableString();\r\n  }\r\n}\r\n;\r\n"]}