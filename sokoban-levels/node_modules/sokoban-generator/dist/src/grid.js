"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _tiles = require("./tiles");

var _seedrandom = require("seedrandom");

var _seedrandom2 = _interopRequireDefault(_seedrandom);

var _direction = require("./direction");

var _matrix = require("./matrix");

var _matrix2 = _interopRequireDefault(_matrix);

var _util = require("./util");

var _template = require("./template");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Grid = function () {
  function Grid() {
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var box = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;
    var seed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var minWall = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var playerPos = arguments[5];

    _classCallCheck(this, Grid);

    this._width = width;
    this._height = height;
    this._box = box;
    this._data = new _matrix2.default(this._width, this._height, _tiles.FLOOR);
    this._rand = (0, _seedrandom2.default)(seed);
    this._seed = seed;
    this._minWall = minWall;
    this._playerFixedPos = playerPos;
    this._solutionStep = -1;
  }

  _createClass(Grid, [{
    key: "get",
    value: function get(x, y) {
      return this._data.get(x, y);
    }
  }, {
    key: "set",
    value: function set(x, y, tile) {
      this._data.set(x, y, tile);
    }
  }, {
    key: "setMatrixAsArray",
    value: function setMatrixAsArray(array) {
      this._data.setAsArray(array);
    }

    /**
     * Wrapper to move a tile
     * @param x
     * @param y
     * @param direction
     * @return boolean if the move is legit and successful
     */

  }, {
    key: "move",
    value: function move(x, y, direction) {
      return this._data.move(x, y, direction);
    }
  }, {
    key: "isInRange",
    value: function isInRange(x, y) {
      return this._data.isInRange(x, y);
    }
  }, {
    key: "clone",
    value: function clone() {
      var newGrid = new Grid(this._width, this._height, this._box, this._seed, this._minWall, this._playerFixedPos);
      newGrid._data = this._data.clone();
      newGrid._solutionStep = this._solutionStep;

      return newGrid;
    }

    /**
     * If the grid has a solvable level, this will return the step needed to
     * solve it. Only call this after a puzzle has been successfully generated
     * @return {number|*}
     */

  }, {
    key: "getSolutionStep",
    value: function getSolutionStep() {
      return this._solutionStep;
    }

    /**
     * Resets the grid and apply template.
     * @return boolean - true if one is generated successfully
     */

  }, {
    key: "applyTemplates",
    value: function applyTemplates() {
      var wallCount = 0;

      for (var x = 0; x < this._width; x += _template.TEMPLATE_SIZE) {
        for (var y = 0; y < this._height; y += _template.TEMPLATE_SIZE) {
          wallCount += this._applyTemplate(x, y);
        }
      }

      if (this._playerFixedPos) {
        if (this._data.isWall(this._playerFixedPos.x, this._playerFixedPos.y)) {
          return false;
        }
      }

      return wallCount >= this._minWall;
    }

    /**
     * Applies a single template at (x,y)
     * @param x
     * @param y
     * @return {Number} the number of walls, or -1 if not created successfully
     * @private
     *
     */

  }, {
    key: "_applyTemplate",
    value: function _applyTemplate(x, y) {
      // Choose a random template
      var temp = _template.Templates[Math.floor(this._rand() * _template.Templates.length)];
      var i = 0;
      var t = 0;

      for (var dx = 0; dx < _template.TEMPLATE_SIZE && x + dx < this._width; ++dx) {
        for (var dy = 0; dy < _template.TEMPLATE_SIZE && y + dy < this._height; ++dy, ++i) {
          if (temp[i] === _tiles.WALL) {
            ++t;
          }

          this.set(x + dx, y + dy, temp[i]);
        }
      }

      return t;
    }

    /**
     * Applies a string grid to this class
     * @param {String} str
     */

  }, {
    key: "applyStringGrid",
    value: function applyStringGrid(str) {
      var i = 0;

      for (var y = 0; y < this._height; ++y) {
        for (var x = 0; x < this._width; ++x) {
          this.set(x, y, str[i++]);
        }
      }
    }

    /**
     * Checks several things to make sure current grid is a good one for sokoban
     */

  }, {
    key: "isGoodCandidate",
    value: function isGoodCandidate() {
      return this._data.isAllConnected() && !this._data.hasLargeEmptySpace() && this.hasEnoughRoom() && !this._data.hasDeadEnd();
    }
  }, {
    key: "hasEnoughRoom",
    value: function hasEnoughRoom() {
      return this._data.count(_tiles.FLOOR) >= this._box + 2; // one for player, the
      // other for moving
    }

    /**
     * Wipes out any goals placed (if any) and randomly deploy goals on the
     * floor
     */

  }, {
    key: "redeployGoals",
    value: function redeployGoals() {
      this._data.clearGoals();

      // Find all floors
      var floors = [];
      for (var x = 0; x < this._width; ++x) {
        for (var y = 0; y < this._height; ++y) {
          if (this.get(x, y) === _tiles.FLOOR) {
            floors.push({ x: x, y: y });
          }
        }
      }

      if (floors.length <= this._box) {
        return false;
      }

      // Randomly choose by shuffling
      var i = floors.length;
      while (--i) {
        var j = Math.floor(this._rand() * (i + 1));

        var _ref = [floors[j], floors[i]];
        floors[i] = _ref[0];
        floors[j] = _ref[1];
      }

      // Set the first several to be goals
      for (var _i = 0; _i < this._box; ++_i) {
        var _floors$_i = floors[_i],
            _x6 = _floors$_i.x,
            _y = _floors$_i.y;

        this.set(_x6, _y, _tiles.GOAL);
      }

      return true;
    }

    /**
     * Wipes out boxes, put them back to their goals and find the farthest
     * position each box can be
     */

  }, {
    key: "generateFarthestBoxes",
    value: function generateFarthestBoxes() {
      var boxes = this._data.resetBoxesToGoals();

      // Backtrack maps
      var map = {};
      var playerPos = this._data.findAvailablePlayerPositions();

      // Generate all possible maps
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = playerPos[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var pos = _step.value;

          this._pullBoxes(boxes, pos, map);
        }

        // Iterate over map to find the farthest one
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var keys = Object.keys(map);
      var maxMap = "";
      var maxPos = null;
      var max = -1;

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var key = _step2.value;

          var matrix = map[key];

          for (var _x7 = 0; _x7 < this._width; ++_x7) {
            for (var _y2 = 0; _y2 < this._height; ++_y2) {
              if (!matrix[_y2][_x7] || matrix[_y2][_x7] <= max) {
                continue;
              }

              if (this._playerFixedPos) {
                // The player position is fixed, so we need to know if current
                // position is accessible by the player (to move the player
                // position later)
                this.applyStringGrid(key);
                if (!this._data.isAccessible(this._playerFixedPos.x, this._playerFixedPos.y, _x7, _y2)) {
                  continue;
                }
              }

              maxMap = key;
              maxPos = { x: _x7, y: _y2 };
              max = matrix[_y2][_x7];
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (maxPos === null) {
        return false;
      }

      this._solutionStep = max;
      this.applyStringGrid(maxMap);

      // Set player position
      var x = this._playerFixedPos ? this._playerFixedPos.x : maxPos.x;
      var y = this._playerFixedPos ? this._playerFixedPos.y : maxPos.y;
      var tile = this.get(x, y) === _tiles.GOAL ? _tiles.PLAYER_GOAL : _tiles.PLAYER;

      this.set(x, y, tile);

      return true;
    }

    //region private functions

    /**
     * Generates an empty matrix based on current width and height
     * @return {any[][]}
     * @private
     */

  }, {
    key: "_emptyMatrix",
    value: function _emptyMatrix(initValue) {
      return (0, _util.emptyMatrix)(this._width, this._height, initValue);
    }

    /**
     * Returns actual x and y coordinate given an index in the string
     * @param index
     * @return {{x: number, y: number}}
     * @private
     */

  }, {
    key: "_toCoord",
    value: function _toCoord(index) {
      var x = Math.floor(index / this._width);

      return {
        x: x,
        y: index - x * this._width
      };
    }

    /**
     * To index
     * @param x
     * @param y
     * @return {Number}
     * @private
     */

  }, {
    key: "_toIndex",
    value: function _toIndex(x, y) {
      return x * this._width + y;
    }

    /**
     * Pull all boxes to a random position (using bfs)
     * @param {Array} initBoxes - an array of positions in the form of {x:number,
     *   y:number}
     * @param {{x:number, y:number}} initPos - current position of player
     * @param {Object} map - a backtrack map to keep track of what kind of grids
     *   have been explored, with each key as a string, and value as a 2d array
     *   to keep track of the steps when the player is at that specific location
     * @private
     */

  }, {
    key: "_pullBoxes",
    value: function _pullBoxes(initBoxes, initPos, map) {
      var size = 0;
      var stack = [{
        boxes: initBoxes.map(function (b) {
          return _extends({}, b);
        }),
        pos: _extends({}, initPos),
        matrix: this._data.clone(),
        step: 0
      }];

      while (stack.length) {
        size = Math.max(stack.length, size);
        var top = stack.shift();
        var boxes = top.boxes,
            pos = top.pos,
            matrix = top.matrix,
            step = top.step;


        if (this._pullBoxesCheckIfMapCached(map, top)) {
          continue;
        }

        for (var i = 0; i < boxes.length; ++i) {
          var box = boxes[i];

          // Go each direction
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = _direction.DIRECTIONS[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var direction = _step3.value;
              var x = box.x,
                  y = box.y;

              var newBoxPos = (0, _direction.moveToDirection)(x, y, direction);

              if (!matrix.isAccessible(pos.x, pos.y, newBoxPos.x, newBoxPos.y)) {
                continue;
              }

              var newPlayerPos = (0, _direction.moveToDirection)(newBoxPos.x, newBoxPos.y, direction);

              if (!matrix.isAccessible(pos.x, pos.y, newPlayerPos.x, newPlayerPos.y)) {
                continue;
              }

              var matrixCopy = matrix.clone();
              if (!matrixCopy.move(x, y, direction)) {
                continue;
              }

              // Set new box position
              var boxesCopy = boxes.map(function (a) {
                return _extends({}, a);
              });
              boxesCopy[i] = newBoxPos;
              stack.push({
                boxes: boxesCopy,
                pos: newPlayerPos,
                matrix: matrixCopy,
                step: step + 1
              });
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }
      }
    }

    /**
     * A helper function for _pullBoxes to check if the map has cached value,
     * and modify the map accordingly
     * @param map
     * @param {{step:number, pos:object, matrix:Matrix}} obj - an object stored in
     *   the stack of _pullBoxes when doing bfs
     * @private
     */

  }, {
    key: "_pullBoxesCheckIfMapCached",
    value: function _pullBoxesCheckIfMapCached(map, obj) {
      var step = obj.step,
          pos = obj.pos,
          matrix = obj.matrix;
      var x = pos.x,
          y = pos.y;


      if (step === 0) {
        return false;
      }

      var str = matrix.toString();

      // Check if the value is already cached
      if (map[str]) {
        if (map[str][y][x]) {
          if (step < map[str][y][x]) {
            this._pullBoxesPropagateMapStepValue(matrix, map[str], x, y, step);
          }

          return true;
        }
      }

      if (!map[str]) {
        map[str] = this._emptyMatrix(0);
      }

      this._pullBoxesPropagateMapStepValue(matrix, map[str], x, y, step, true);

      return false;
    }

    /**
     * Use dfs to make sure connected cells has synced step value
     * @param {Matrix} matrix
     * @param {Array[][]} playerMatrix - a 2d matrix that caches the max step of
     *   player
     * @param x
     * @param y
     * @param step
     * @param {boolean} setValue - true if the propagation should set the value
     *   and reference the actual map. Otherwise it will just propagate depending
     *   on if the neighbor has a value
     * @private
     */

  }, {
    key: "_pullBoxesPropagateMapStepValue",
    value: function _pullBoxesPropagateMapStepValue(matrix, playerMatrix, x, y, step) {
      var setValue = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

      // if (setValue ?
      //     (matrix[y][x] === step || !this._isWalkable(x, y)) : !matrix[y][x]) {
      if (playerMatrix[y][x] === step || !matrix.isWalkable(x, y)) {
        return;
      }

      playerMatrix[y][x] = step;

      if (x > 0) {
        this._pullBoxesPropagateMapStepValue(matrix, playerMatrix, x - 1, y, step, setValue);
      }

      if (x < this._width - 1) {
        this._pullBoxesPropagateMapStepValue(matrix, playerMatrix, x + 1, y, step, setValue);
      }

      if (y > 0) {
        this._pullBoxesPropagateMapStepValue(matrix, playerMatrix, x, y - 1, step, setValue);
      }

      if (y < this._height - 1) {
        this._pullBoxesPropagateMapStepValue(matrix, playerMatrix, x, y + 1, step, setValue);
      }
    }

    /**
     * Returns a copy of a 2d array current _data
     * @private
     */

  }, {
    key: "_copy2dArray",
    value: function _copy2dArray() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._data;

      return data.map(function (a) {
        return a.slice();
      });
    }

    //endregion

  }, {
    key: "toString",
    value: function toString() {
      return this._data.toString();
    }
  }, {
    key: "toReadableString",
    value: function toReadableString() {
      return this._data.toReadableString();
    }
  }]);

  return Grid;
}();

exports.default = Grid;

;
//# sourceMappingURL=grid.js.map