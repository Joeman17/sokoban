{"version":3,"sources":["../../src/matrix.js"],"names":["Matrix","width","height","initValue","_width","_height","_data","_emptyMatrix","x","y","tile","arr","map","a","slice","direction","isMovable","coord","x2","y2","isInRange","isWalkable","src","get","dest","set","newMatrix","indexOf","c","clone","_propagateFloorWith","some","row","includes","qualify3x3","index","last","last2","curr","t","i","isWall","notWall","goals","push","pos","isEdgeConsideredTile","is","x1","y1","w","h","bind","helper","visited","array","join"],"mappings":"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","file":"matrix.js","sourcesContent":["import {\r\n  addMovableTile,\r\n  BOX,\r\n  BOX_GOAL,\r\n  extractMovableTile,\r\n  FLOOR,\r\n  GOAL,\r\n  isMovableTile,\r\n  isWalkableTile,\r\n  removeMovableTile,\r\n  WALL\r\n} from \"./tiles\";\r\nimport {moveToDirection} from \"./direction\";\r\nimport {emptyMatrix} from \"./util\";\r\n\r\nexport default class Matrix {\r\n  constructor(width, height, initValue) {\r\n    this._width = width;\r\n    this._height = height;\r\n    this._data = this._emptyMatrix(width, height, initValue);\r\n  }\r\n\r\n  get(x, y) {\r\n    return this._data[y][x];\r\n  }\r\n\r\n  set(x, y, tile) {\r\n    this._data[y][x] = tile;\r\n  }\r\n\r\n  setAsArray(arr) {\r\n    this._data = arr.map(a => a.slice());\r\n  }\r\n\r\n  /**\r\n   * Moves a tile to a certain direction. The movable tile is either player or\r\n   * box. This function does not cause ripple effect (i.e. moving a player to a\r\n   * box does not push it further, and it's also a invalid move)\r\n   * @param x\r\n   * @param y\r\n   * @param direction\r\n   * @return boolean if the move is legit and successful\r\n   */\r\n  move(x, y, direction) {\r\n    if (!this.isMovable(x, y)) {\r\n      return false;\r\n    }\r\n\r\n    let coord = moveToDirection(x, y, direction);\r\n    let x2 = coord.x;\r\n    let y2 = coord.y;\r\n\r\n    if (!this.isInRange(x2, y2) || !this.isWalkable(x2, y2)) {\r\n      return false;\r\n    }\r\n\r\n    let src = this.get(x, y,);\r\n    let dest = this.get(x2, y2);\r\n    let tile = extractMovableTile(src);\r\n\r\n    this.set(x, y, removeMovableTile(src));\r\n    this.set(x2, y2, addMovableTile(dest, tile));\r\n\r\n    return true;\r\n  }\r\n\r\n  clone() {\r\n    let newMatrix = new Matrix(this._width, this._height);\r\n    newMatrix._data = this._data.map(a => a.slice());\r\n\r\n    return newMatrix;\r\n  }\r\n\r\n  /**\r\n   * Returns if current grid can be is all connected\r\n   */\r\n  isAllConnected() {\r\n    // Find first floor\r\n    let x = 0;\r\n    let y = 0;\r\n    for (; y < this._height; ++y) {\r\n      x = this._data[y].indexOf(FLOOR);\r\n\r\n      if (x !== -1) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (x === -1) {\r\n      return false;\r\n    }\r\n\r\n    let c = this.clone();\r\n    c._propagateFloorWith(x, y);\r\n\r\n    return !c._data.some(row => row.includes(FLOOR));\r\n  }\r\n\r\n  /**\r\n   * Returns whether the grid has empty area larger than 4x3 or 3x4\r\n   */\r\n  hasLargeEmptySpace() {\r\n    let map = {};\r\n    let qualify3x3 = {};\r\n\r\n    // Find all indices with three space\r\n    let index = 0;\r\n    for (let x = 0; x < this._height; ++x, index += 2) {\r\n      let last = false;\r\n      let last2 = false;\r\n\r\n      for (let y = 0; y < this._width - 2; ++y, ++index) {\r\n        let curr = this._data[y][x] === FLOOR;\r\n\r\n        if (curr && last && last2) {\r\n          // Check up 3x3\r\n          if (map[index - this._width] && map[index - this._width - this._width]) {\r\n            // Check 4x3 or 3x4\r\n            if (qualify3x3[index - this._width] || qualify3x3[index - 1]) {\r\n              return true;\r\n            }\r\n            qualify3x3[index] = true;\r\n          }\r\n\r\n          map[index] = true;\r\n        }\r\n\r\n        last2 = last;\r\n        last = curr;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  count(t) {\r\n    let i = 0;\r\n    for (let row of this._data) {\r\n      for (let tile of row) {\r\n        if (tile === t) {\r\n          ++i;\r\n        }\r\n      }\r\n    }\r\n\r\n    return i;\r\n  }\r\n\r\n  hasDeadEnd() {\r\n    for (let x = 0; x < this._width; ++x) {\r\n      for (let y = 0; y < this._height; ++y) {\r\n        if (this.isWall(x, y)) {\r\n          continue;\r\n        }\r\n\r\n        // this._data[i] !== WALL\r\n        let notWall = (!this.isWall(x, y - 1) ? 1 : 0);\r\n\r\n        notWall += (!this.isWall(x - 1, y) ? 1 : 0);\r\n        if (notWall > 1) {\r\n          continue;\r\n        }\r\n\r\n        notWall += (!this.isWall(x + 1, y) ? 1 : 0);\r\n        if (notWall > 1) {\r\n          continue;\r\n        } else if (notWall === 0) {\r\n          return true;\r\n        }\r\n\r\n        notWall += (!this.isWall(x, y + 1) ? 1 : 0);\r\n        if (notWall <= 1) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Puts boxes back to their goals and returns the final positions of the\r\n   * boxes (or goals)\r\n   */\r\n  resetBoxesToGoals() {\r\n    let goals = [];\r\n\r\n    for (let y = 0; y < this._height; ++y) {\r\n      for (let x = 0; x < this._width; ++x) {\r\n        let tile = this.get(x, y);\r\n        if (tile === BOX) {\r\n          this.set(x, y, FLOOR);\r\n        } else if (tile === GOAL) {\r\n          goals.push({x, y});\r\n          this.set(x, y, BOX_GOAL);\r\n        } else if (tile === BOX_GOAL) {\r\n          goals.push({x, y});\r\n        }\r\n      }\r\n    }\r\n\r\n    return goals;\r\n  }\r\n\r\n  /**\r\n   * Finds all available player starting positions\r\n   * @return {[{x: number, y: number}]} A list of player positions. Each\r\n   *   position is mutually non-accessible by other positions in the list.\r\n   */\r\n  findAvailablePlayerPositions() {\r\n    let c = this.clone();\r\n    let pos = [];\r\n\r\n    for (let x = 0; x < this._width; ++x) {\r\n      for (let y = 0; y < this._height; ++y) {\r\n        if (c.get(x, y) === FLOOR) {\r\n          pos.push({x, y});\r\n          c._propagateFloorWith(x, y, WALL);\r\n        }\r\n      }\r\n    }\r\n\r\n    return pos;\r\n  }\r\n\r\n  is(x, y, tile, isEdgeConsideredTile = false) {\r\n    if (!this.isInRange(x, y)) {\r\n      return isEdgeConsideredTile;\r\n    }\r\n\r\n    return this.get(x, y) === tile;\r\n  }\r\n\r\n  /**\r\n   * Returns if a given tile is a wall\r\n   * @param x\r\n   * @param y\r\n   * @return {boolean}\r\n   */\r\n  isWall(x, y) {\r\n    return this.is(x, y, WALL, true);\r\n  }\r\n\r\n  isInRange(x, y) {\r\n    return x >= 0 && x < this._width && y >= 0 && y < this._height;\r\n  }\r\n\r\n  /**\r\n   * Returns if (x1, y1) is accessible from (x2, y2)\r\n   * @param x1\r\n   * @param y1\r\n   * @param x2\r\n   * @param y2\r\n   * @param {array} [array] - if provided, this function will process this map\r\n   *   instead of this._data. Should be of the same dimension as that of\r\n   *   this._data\r\n   * @return boolean\r\n   */\r\n  isAccessible(x1, y1, x2, y2) {\r\n    if (!this.isInRange(x1, y1) || !this.isInRange(x2, y2) ||\r\n      !this.isWalkable(x1, y1) || !this.isWalkable(x2, y2)) {\r\n      return false;\r\n    }\r\n\r\n    let w = this._width;\r\n    let h = this._height;\r\n    let is = this.isWalkable.bind(this);\r\n\r\n    // For this helper, we make sure (x,y) and (destX,destY) is always in\r\n    // range, and we only change the value of x and y\r\n    return (function helper(x, y, visited) {\r\n      if (visited[y][x]) {\r\n        return false;\r\n      }\r\n      visited[y][x] = true;\r\n\r\n      if (x === x2 && y === y2) {\r\n        return true;\r\n      }\r\n\r\n      if (x > 0 && is(x - 1, y) && helper(x - 1, y, visited)) {\r\n        return true;\r\n      }\r\n      if (x < w - 1 && is(x + 1, y) && helper(x + 1, y, visited)) {\r\n        return true;\r\n      }\r\n      if (y > 0 && is(x, y - 1) && helper(x, y - 1, visited)) {\r\n        return true;\r\n      }\r\n      if (y < h - 1 && is(x, y + 1) && helper(x, y + 1, visited)) {\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    })(x1, y1, this._emptyMatrix());\r\n  }\r\n\r\n  /**\r\n   * ASSUMING (x,y) IS VALID. Returns if (x,y) is walkable.\r\n   * @param x\r\n   * @param y\r\n   * @param {Array} [array] - optional array to process instead of this._data\r\n   */\r\n  isWalkable(x, y, array) {\r\n    return isWalkableTile(this.get(x, y, array));\r\n  }\r\n\r\n  /**\r\n   * Returns if the tile at (x,y) is movable\r\n   * @param x\r\n   * @param y\r\n   * @param [array] - if specified, will be processed instead of this._data\r\n   */\r\n  isMovable(x, y, array) {\r\n    if (!this.isInRange(x, y)) {\r\n      return false;\r\n    }\r\n\r\n    let tile = this.get(x, y, array);\r\n    return isMovableTile(tile);\r\n  }\r\n\r\n  /**\r\n   * Removes any goals tiles. This method assumes that only goal tile is GOAL\r\n   * (thus excluding player or boxes already on goal)\r\n   */\r\n  clearGoals() {\r\n    for (let row of this._data) {\r\n      for (let i = 0; i < this._width; ++i) {\r\n        if (row[i] === GOAL) {\r\n          row[i] = FLOOR;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Uses DFS to spread wall at a given location\r\n   * @param x\r\n   * @param y\r\n   * @param tile\r\n   * @private\r\n   */\r\n  _propagateFloorWith(x, y, tile = WALL) {\r\n    if (!this.is(x, y, FLOOR)) {\r\n      return;\r\n    }\r\n\r\n    this.set(x, y, tile);\r\n\r\n    this._propagateFloorWith(x - 1, y, tile);\r\n    this._propagateFloorWith(x + 1, y, tile);\r\n    this._propagateFloorWith(x, y - 1, tile);\r\n    this._propagateFloorWith(x, y + 1, tile);\r\n  }\r\n\r\n  _emptyMatrix(width = this._width, height = this._height, initValue) {\r\n    return emptyMatrix(width, height, initValue);\r\n  }\r\n\r\n  toString() {\r\n    return this._data.map(a => a.join(\"\")).join(\"\");\r\n  }\r\n\r\n  toReadableString() {\r\n    return this._data.map(a => a.join(\"\")).join(\"\\n\");\r\n  }\r\n}"]}